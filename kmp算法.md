### 字符串的匹配问题
- 问题描述：在原串n中寻找是否存在模式串m
- 暴力的做法的时间复杂度是o(nm),使用kmp算法可以达到o(n+m)
- 核心：PMT即部分匹配表，表中记录了在模式串中以第i个字符结尾的字符字串的最长公共前后缀
- 思想：当原串的第i个字符和模式串的第j个字符不匹配，i不用回退，j根据PMT回退

#### 求PMT
- 以模式串的第一位开始对自身做匹配运算，能够匹配到的最大长度就是对应长度的最大公共前后缀
  - 这里我们将模式串和它自身分别设为s1和s2,两个指针i,j是分别指向s1[1]和s2[0]的(对比起始位置没有意义，自身不能成为自身的前缀)，PMT[i]就是以i结尾的子串的最长公共前后缀
  - 如果s1[1]==s2[0]那么以长度为2的字符串的最长公共前后缀就是1,那我们将继续对比s1[2]和s2[1];否则就是0，那我们将对比s1[2]和s2[0]
  - 那我们假设此时对比的是s1[i]和s2[j],
    - 如果s1[i]==s2[j],那么i和j将同时加一，此时PMT[i]=PMT[i-1]+1,那么可能存在更长的公共前后缀吗？
      - 不可能，假如存在更大PMT[i]，我们将i回退一格PMT[i-1]也将变大。 
    - 如果s1[i]!=s2[j],那么j将回退到0，也就是说长度为i的字串的最长公共前后缀的长度是0，当i，j匹配不上的时候长度为i的子串最长公共前后缀一定是0？
      - 假如存在非0的PMT[i],由上条可知,显然不会超过PMT[i-1]+1
