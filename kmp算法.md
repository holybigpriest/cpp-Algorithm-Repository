### 字符串的匹配问题
- 问题描述：在原串n中寻找是否存在模式串m
- 暴力的做法的时间复杂度是o(nm),使用kmp算法可以达到o(n+m)
- 核心：PMT即部分匹配表，表中记录了在模式串中以第i个字符结尾的字符字串的最长公共前后缀
- 思想：当原串的第i个字符和模式串的第j个字符不匹配，i不用回退，j根据PMT回退
```
如果原串s1[i]不等于模式串s2[j],那么j将回退到PMT[j-1]，那么为什么会是这里？
1. 当j!=0时，s1[i]!=s2[j]同时也说明s1的i-j到i和s2的0-j相同。
2. 倘若s1中有子串能和s2相同或者说相匹配，并且在s1中以i-j和i-1中元素开头，不妨设为k
3. 那么s1中[k,i-1]的元素会等于s2中[0,i-k-1]，实际上会是s2中[0,j-1]字符串的前缀子串，
4. 而由1可知s1中[k,i-1]的元素会等于s2中[k-i+j,j-1]
5. 那我们如果知道[0,j-1]的最长公共前后缀，就可以跳过i回退的过程
我们以abababca举例，
长度为1时，自身不能成为自身前缀PMT[0]=0;
长度为2时,i=1,j=0,
        a b
          a b
由于a!=b,PMT[1]=0;
长度为3时,i=2,j=0,
        a b a
            a b a
s1[i]=s2[j],因此PMT[2]=1;
由此类推当i=6时,j=4
        a b a b a b c a
            a b a b a b c a
s1[i]!=s2[j]，我们在s1中的[i-j,i-1]能找到子串ab和s2部分匹配，显然这部分是s2[0,j-1]的后缀，当找到部分匹配的时候这部分是s2[0,j-1]的前缀
因此，我们可以跳过i的回退，只将j将回退到PMT[j-1],s1[i-PMT[j-1],i]和s2[0,PMT[j-1]]是相同的
```
#### 求PMT
- 以模式串的第一位开始对自身做匹配运算，能够匹配到的最大长度就是对应长度的最大公共前后缀
  - 这里我们将模式串和它自身分别设为s1和s2,两个指针i,j是分别指向s1[1]和s2[0]的(对比起始位置没有意义，自身不能成为自身的前缀)，PMT[i]就是以i结尾的子串的最长公共前后缀
  - 如果s1[1]==s2[0]那么以长度为2的字符串的最长公共前后缀就是1,那我们将继续对比s1[2]和s2[1];否则就是0，那我们将对比s1[2]和s2[0]
  - 那我们假设此时对比的是s1[i]和s2[j],
    - 如果s1[i]==s2[j],那么i和j将同时加一，此时PMT[i]=PMT[i-1]+1,那么可能存在更长的公共前后缀吗？
      - 不可能，假如存在更大PMT[i]，我们将i回退一格PMT[i-1]也将变大。 
    - 如果s1[i]!=s2[j],那么j将回退到PMT[j-1]。
